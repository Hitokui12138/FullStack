# 总结整个异常处理的流程
1. 新建异常类
        - HttpException -> RuntimeException
            - 其他详细异常 -> HttpException
2. 做一个`UnifyResponse`类,保存code,msg,url等信息,用来返回给前端
    - 只是一个类似Entity的存在
3. 做一个`ExceptionCodeatioConfiguration`类用来读取配置文件
    1. 注解
        1. `@PropertySource(value = "classpath:config/exception-code.properties")`,标明配置文件的地址
        2. `@ConfigurationProperties(prefix = "lin")`,仅读取文件中以`lin`开头的
        3. `@Component`,为了让让统一异常处理类可以用里面的东西,需要一个实例
    2. 有了以上注解,直接用一个Map就能自动接收文件里的值
        - private Map<Integer, String> codes = new HashMap<>();
        - 要求名字必须是和配置文件一样
            ```yaml
            lin.codes[10000] = CustomizeError0错误0
            lin.codes[10001] = CustomizeError1错误1
            ```
3. 统一异常处理类,GlobalExceptionAdvice
    1. `@ControllerAdvice`, 标明一个用于处理异常的类
    2. `@Autowired`, 异常信息文件的实例,ExceptionCodeatioConfiguration
    3. `@ExceptionHandler(value=Exception.class) `,标记具体异常的处理方法,将信息返回给前端
        1. 方法1: 通用异常,返回`UnifyResponse`
            1. Java不能直接返回对象给前端,因此加上`@ResponseBody`
            2. HTTP状态码,直接返回500
                - `@ResponseStatus(code = HttpStatusINTERNAL_SERVER_ERROR)`
            3. 返回UnifyResponse
                - new UnifyResponse(10001,messages,method + " " +requestUrl);
        2. 方法2: 从配置文件读取的特殊异常,返`ResponseEntity<UnifyResponse>`
            1. 不需要@ResponseBody
            1. ResponseEntity需要三个参数
                - `new ResponseEntity<>(unifyResponse,httpHeadershttpStatus);`
                1. unifyResponse
                    - 把读取到的ExceptionCodeatioConfiguration的信息存进去
                2. httpHeaders
                    - 由于没有@ResponseBody,所以需要
                    - `new HttpHeaders.setContentType(MediaTypeAPPLICATION_JSON)`
                3. httpStatus
                    - HttpStatus.resolve(设置的httpStatus);