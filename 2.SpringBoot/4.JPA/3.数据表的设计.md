# ORM自动生成表和手动做成
1. 长度要求
    1. 使用@Entity自动生成后,不进行限制的话
        1. String类型都是255
        2. long,20
    2. 结合@Column(length=10)使用
2. 唯一索引
    1. `物理外键`,`逻辑外键`
        1. 物理外键
            - 物理外键指的是使用foreign key 作为外键关联另一张的字段
            - 影响性能
        2. 逻辑外键
            - 不使用foreignkey,使用语法产生逻辑关联而产生的外键
        - 对于Web项目,变化很多,因此不推荐使用物理外键(在外键Tab下面能看到)
        - 物理外键好处在于强约束保持数据一致性,但是可能会造成效率较差
        - 比如如果想删banner,那就必须先把bannerItem同id的给删掉才行
            - 或者在逻辑中对外键id进行校验
    2. 设置id自增涨
        - @GeneratedValue(strategy = )
3. 优点:
    - 这个最大的优点是实体与实体之间的关系配置
    - 如果都用单表查询的话,数据库执行效率高,但是java开发的效率低
# 表与表的关系
- 每次设计一张表,分析这张表与其他的表的三个关系是最重要的
1. `一对一`,一个人只有一个身份证号码
    - 还需要分析主表和从表,不是一个必须的关系
    1. 什么时候需要一对一的表?
        - 如果一个表的数据过多(比如有100个以上的字段),考虑到`查询效率`,此时建议分成5个表以上
        - 业务的角度,希望不同的业务能归类在不同的表里面
2. `一对多`,一个班级有多个学生
    - 最常见的关系
    - 单向一堆多,单向多对多
3. `多对多`,老师和学生的关系,一个老师教多个学生,一个学生也有多个老师
    - 两张表往往无法表示多对多的关系,至少需要`三张表`
    1. theme与spu就是多对多的关系
        - theme表,spu表,theme_spu表
        - 至少需要三个属性,id,themeid,spuid,这样就可以表示多对多的关系了
    2. 第三张表是`无实际意义`的表吗?
        1. 无意义的第三张表,仅仅表示两个表的关系
        2. 除了关系,本身也`有业务意义的第三张表`,user_coupon
            - 这个优惠券,用户有没有使用过?这个状态status应该记录在第三张表里
            - 这个优惠券被使用的订单ID,orderID,使用时间
# 数据库的设计
1. 把表想象成一个实体对象来看待,而不是一个表
    - 业务->业务对象(Coupon,order,user)
2. 思考对象与对象之间的关系
    - 数据库是使用`外键`来建立联系的
    - 父数据表（Parent Entity）的主键（Primary Key）会放在另一个数据表，做属性以建立彼此的关系，而这个属性就是外键。
3. 细化,优化
    1. 长度限制,小数点,唯一索引
    2. 数据库承载上限是5000万条,但是尽量少一些
        - `建立索引`: 更加效率查询
        - `水平分表`: 把一个表分成多个表,每个表承担一定范围的id的数据
        - `垂直分割`: 如果一个表的字段超过100个,考虑分成多个一对一的表,从而高查询效率
4. 但对查询效率影响最大的是查询方式而不是数据库设计
    1. like %,效率很差
5. 新技术: `利用缓存`,尽可能减少查询数据库的次数
    - 这个是对数据库优化的`最有效的方式`
    1. 把查询到的数据保存在`Redis`之类的键值对的数据库里面去
        - 硬件上CPU也是利用一级二级三级缓存来提升效率的
    2. 之后的查询优先去缓存中数据

# 用JPA标识两个实体的关系
- banner是一,bannerItem是多
1. java构建单向一堆多关系
    ```java
    @Entity
    public class Banner {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY) //自增长
        private long id;
        
        @OneToMany//1. 声明一对多的关系
        @JoinColumn(name = "bannerId")//2. 指定外键
        private List<BannerItem> items;// 称这个属性为“导航属性”
    }

    @Entity
    public class BannerItem {
        @Id
        private long id;
        private long bannerId;
    }
    ```
