# 用JPA实现SQL
1. 建一个新包repository
    - 衔接repository和service的话,定义一个interface
    - 需要`继承JpaRepository<,>`
    - 只要定义的方法符合格式,就不需要定义方法的实现就能完成数据库的查询
    ```java
    public interface BannerRepository extends JpaRepository<Banner, Long> {
        //只要定义一个方法签名就行
        Banner findOneById(Long i);
        Banner findOneByName(String name);
    }

    //然后在ServiceImpl里面调用
    ```
    1. 如何验证确实是查询了数据库呢?
        1. 在数据库里面加数据
        2. 直接在控制台里可以看到SQL语句
            ```yml
            spring:
                jpa:
                    properties:
                        hibernate:
                            show_sql: true
                            format_sql: true
            ```
            1. 有时需要查询bannerItem,有时只需要banner的数据就可以了
                - JPA默认就是`懒加载`,可以改成`急加载`,不过不建议
                - `@OneToMany(fetch = FetchType.EAGER) `
2. 分析层级
    - api->service->repository->数据库
    - modle仅用于定于模型,不算是层级的一部分,有点像类库

# 单向一对多与双向一对多
1. 现在在Banner里面定义List<BannerItem>是`单向一对多`
    - 这个List被称为`导航属性`
    ```java
    //单向关系
    //Banner
    @OneToMany
    @JoinColumn(name = "bannerId")
    private List<BannerItem> items;

    //BannerItem
    //@ManyToOne
    //@JoinColumn(name = "bannerId")//应该打在关系维护端这边
    //private Banner banner;//不需要导航属性
    ```
2. 也可以在BannerItem里定义List<Banner>以实现另一个方向的单向一对多
3. 同时在两个表里定义List则是`双向一对多`,注意三点
    ```java
    //Banner
    @OneToMany(mappedby = "banner")//3. 这个参数是banneritem的导航属性的名字
    //@JoinColumn(name = "bannerId")// 这个打在关系维护方,多端
    private List<BannerItem> items;

    //BannerItem
    @ManyToOne
    @JoinColumn(name = "bannerId")//2. 应该打在关系维护端这边
    private Banner banner;//1. 导航属性
    ```
    1. 此时,多方是关系的维护端,单方是关系的被维护端