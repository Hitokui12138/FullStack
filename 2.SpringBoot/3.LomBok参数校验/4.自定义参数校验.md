# 自定义校验组件
- 比如注册时,第二遍输入的密码要与第一遍输入的匹配
- JSR303规范
1. 流程
    1. 自定义一个注解
        1. validators包
        2. 创建一个注解类
        ```java
        @Documented//将注释也加入文档
        @Retention(RetentionPolicy.RUNTIME)//保留至运行阶段
        @Target({ElementType.TYPE})//这个注解可以运行到那些对象上
        public @interface PasswordEqual {
            //1.定义一个用来提示的文本
            String message() default "两次密码不相同";
            //2.自定义校验注解的两个模版方法
            Class<?>[] groups() default{};
            Class<? extends Payload>[] payload() default{};
        }
        ```
    2. 注解里面不要写业务逻辑,创建一个关联类来保存业务逻辑
2. 创建关联类
    ```java
    /**
     * 注解的关联类
    * 1. 实现接口ConstraintValidator
    * 2.范型里面
    *      1. 关联的注解的类型,PasswordEqual
    *      2. 修饰的目标的类型,PersonDTO,如果是其他,则String等等
    * 3. 具体校验逻辑写在isValid()里面
    */
    public class PasswordValidator implements ConstraintValidator<PasswordEqual, PersonDTO> {
        @Override
        public boolean isValid(PersonDTO personDTO, ConstraintValidatorContext constraintValidatorContext) {
            String password1 = personDTO.getPassword1();
            String password2 = personDTO.getPassword2();
            boolean match = password1.equals(password2);
            return match;
        }
    }
    ```
3. 将两个类关联在一起
    ```java
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ElementType.TYPE})
    @Constraint(validatedBy = PasswordValidator.class)//传入元类进行关联
    public @interface PasswordEqual {
        String message() default "两次密码不相同";
        Class<?>[] groups() default{};
        Class<? extends Payload>[] payload() default{};
    }
    ```
4. 应该学习Spring的这种`把两个类关联起来的方法`,熟悉这种编程模式
    - 在EnableLOLConfiguration里也有用过
5. 使用注解
    ```java
    @Builder
    @Getter
    @PasswordEqual//在这里使用
    public class PersonDTO {
        @Length(min = 2, max = 10, message = "name长度不符合规范")
        private String name;
        private Integer age;
        @Valid
        private SchoolDTO schoolDTO;

        private String password1;
        private String password2;
    }
    ```
# 接下来,带参数的自定义注解
1. 有一些问题
    1. 前端返回服务器内部异常,定义的message没有用上
    2. 注解@PasswordEqual也是可以接受参数,覆盖默认message的
2. 比如想限制密码的长度
    ```java
    //...
    public @interface PasswordEqual {
        int min() default 4;//在注解里只能用基本类型
        int max() default 20;
        String message() default "两次密码不相同";
        //...
    }

    @PasswordEqual(min = 5)
    public class PersonDTO {}
    ```
3. 然后在PasswordValidator进行业务逻辑判断
    - 问题是如何获得min和max?
    ```java
    public class PasswordValidator implements ConstraintValidator<PasswordEqual, PersonDTO> {
        private int min;
        private int max;
        private String message;
        /**
         * 这个方法可以拿到注解上的参数
        */
        @Override
        public void initialize(PasswordEqual constraintAnnotation) {
            this.min = constraintAnnotation.min();
            this.max = constraintAnnotation.max();
            this.message = constraintAnnotation.message();
        }

        /**
         * 这个方法用于进行业务判断
        */
        @Override
        public boolean isValid(PersonDTO personDTO, ConstraintValidatorContext constraintValidatorContext) {
            String password1 = personDTO.getPassword1();
            String password2 = personDTO.getPassword2();
            boolean match = password1.equals(password2);
            //再加入其他判断
            return match;
        }
    }
    ```